package minmaxmed_test

import (
	"bytes"
	"context"
	"encoding/json"
	"runtime"
	"testing"
	"time"

	"github.com/moov-io/base/telemetry"
	"github.com/moov-io/watchman/internal/minmaxmed"

	"github.com/stretchr/testify/require"
	"golang.org/x/sync/errgroup"
)

type AutoGenerated struct {
	Events []struct {
		Attributes []struct {
			Value struct {
				Value float64 `json:"Value"`
				Type  string  `json:"Type"`
			} `json:"Value"`
			Key string `json:"Key"`
		} `json:"Attributes"`
		Name string `json:"Name"`
	} `json:"Events"`
}

func TestMinMaxMed(t *testing.T) {
	t.Run("scores", func(t *testing.T) {
		ctx := context.Background()

		var buf bytes.Buffer
		conf := telemetry.TestConfig(&buf)
		shutdown, err := telemetry.SetupTelemetry(ctx, conf, "v0.1.0")
		require.NoError(t, err)
		t.Cleanup(func() { shutdown() })

		_, span := telemetry.StartSpan(ctx, "minmaxmed-scores")

		m := minmaxmed.New(5)
		m.Add(5)
		m.Add(4)
		m.Add(2)
		m.Add(1)
		m.Add(3)

		m.AddEvent(span)
		span.End()

		var output AutoGenerated
		json.NewDecoder(&buf).Decode(&output)
		require.Len(t, output.Events, 1)

		evt := output.Events[0]
		require.Equal(t, "stats", evt.Name)
		require.Len(t, evt.Attributes, 5)

		for i := range evt.Attributes {
			switch evt.Attributes[i].Key {
			case "min_ms":
				require.Equal(t, int64(1), int64(evt.Attributes[i].Value.Value))
				require.Equal(t, "INT64", evt.Attributes[i].Value.Type)

			case "max_ms":
				require.Equal(t, int64(5), int64(evt.Attributes[i].Value.Value))
				require.Equal(t, "INT64", evt.Attributes[i].Value.Type)

			case "median_ms":
				require.InDelta(t, 3.0, evt.Attributes[i].Value.Value, 1.0)
				require.Equal(t, "FLOAT64", evt.Attributes[i].Value.Type)

			case "average_ms":
				require.InDelta(t, 3, evt.Attributes[i].Value.Value, 1.0)
				require.Equal(t, "FLOAT64", evt.Attributes[i].Value.Type)

			case "observations":
				require.Equal(t, int64(5), int64(evt.Attributes[i].Value.Value))
				require.Equal(t, "INT64", evt.Attributes[i].Value.Type)

			default:
				t.Errorf("unexpected attribute key: %q", evt.Attributes[i].Key)
			}
		}
	})

	t.Run("time", func(t *testing.T) {
		if runtime.GOOS == "windows" {
			t.Skip("time is wonky on Windows")
		}

		ctx := context.Background()

		var buf bytes.Buffer
		conf := telemetry.TestConfig(&buf)
		shutdown, err := telemetry.SetupTelemetry(ctx, conf, "v0.1.0")
		require.NoError(t, err)
		t.Cleanup(func() { shutdown() })

		_, span := telemetry.StartSpan(ctx, "minmaxmed-scores")

		m := minmaxmed.New(5)
		start := time.Now()

		time.Sleep(10 * time.Millisecond)
		m.AddDuration(time.Since(start))
		time.Sleep(20 * time.Millisecond)
		m.AddDuration(time.Since(start))
		time.Sleep(30 * time.Millisecond)
		m.AddDuration(time.Since(start))

		m.AddEvent(span)
		span.End()

		var output AutoGenerated
		json.NewDecoder(&buf).Decode(&output)
		require.Len(t, output.Events, 1)

		evt := output.Events[0]
		require.Equal(t, "stats", evt.Name)
		require.Len(t, evt.Attributes, 5)

		for i := range evt.Attributes {
			switch evt.Attributes[i].Key {
			case "min_ms":
				require.Greater(t, evt.Attributes[i].Value.Value, 0.0)
				require.Equal(t, "INT64", evt.Attributes[i].Value.Type)

			case "max_ms":
				require.Greater(t, evt.Attributes[i].Value.Value, 50.0)
				require.Equal(t, "INT64", evt.Attributes[i].Value.Type)

			case "median_ms":
				require.InDelta(t, 30.0, evt.Attributes[i].Value.Value, 10.0)
				require.Equal(t, "FLOAT64", evt.Attributes[i].Value.Type)

			case "average_ms":
				require.InDelta(t, 30.0, evt.Attributes[i].Value.Value, 10.0)
				require.Equal(t, "FLOAT64", evt.Attributes[i].Value.Type)

			case "observations":
				require.Equal(t, int64(3), int64(evt.Attributes[i].Value.Value))
				require.Equal(t, "INT64", evt.Attributes[i].Value.Type)

			default:
				t.Errorf("unexpected attribute key: %q", evt.Attributes[i].Key)
			}
		}
	})
}

func TestMinMaxMed_Concurrency(t *testing.T) {
	iterations := 500_000

	m := minmaxmed.New(100)

	var g errgroup.Group
	for i := 0; i < iterations; i++ {
		g.Go(func() error {
			n := time.Now().UnixMilli() % 273

			time.Sleep(time.Duration(n) * time.Millisecond)
			m.Add(n)

			return nil
		})
	}

	g.Wait() // wait and make sure we don't panic
}
